package it.codingjam.lagioconda

import akka.actor.{ActorSelection, Scheduler}
import akka.pattern.ask
import com.typesafe.scalalogging.LazyLogging
import it.codingjam.lagioconda.fitness.FitnessFunction
import it.codingjam.lagioconda.ga._
import models.Individual
import it.codingjam.lagioconda.protocol.Message.{CalculateFitness, CalculatedFitness}

import scala.collection.immutable
import scala.concurrent.duration._
import scala.concurrent.{Await, ExecutionContext, Future}
import scala.util.Random

case class Population(generation: Int,
                      individuals: List[Individual],
                      totalFitness: Double,
                      newBestAtGeneration: Int,
                      bestReason: String,
                      hillClimbedGene: Int,
                      lastIncrement: Double,
                      lastResults: List[Double],
                      lastMigrationFrom: Int,
                      trend: String = "")
    extends LazyLogging
    with Retrying {

  implicit val to2 = akka.util.Timeout(60.seconds)

  def rotate(list: List[Double], double: Double) = (list :+ double).takeRight(Population.MaxRotate)

  def nextGeneration(a: ActorSelection)(implicit fitnessFunction: FitnessFunction,
                                        selection: SelectionFunction,
                                        mutation: MutationPointLike,
                                        dimension: ImageDimensions,
                                        crossover: CrossoverPointLike,
                                        temperature: Temperature,
                                        ec: ExecutionContext,
                                        scheduler: Scheduler): Population = {
    var temp = this.crossOver(a, ec)
    val oldBest = this.individuals.head
    var newBest = temp.individuals.head
    var hc = false

    val p = if (oldBest.fitness < newBest.fitness) {
      //println("oldBestF " + oldBest.fitness + " bew best fitness" + newBest.fitness + " generated by " + newBest.generatedBy)
      val lastI = newBest.fitness - oldBest.fitness
      Population(
        generation + 1,
        temp.individuals,
        temp.totalFitness,
        generation + 1,
        newBest.generatedBy,
        temp.hillClimbedGene,
        lastI,
        rotate(temp.lastResults, lastI),
        this.lastMigrationFrom
      )
    } else
      Population(
        generation + 1,
        temp.individuals,
        temp.totalFitness,
        this.newBestAtGeneration,
        oldBest.generatedBy,
        temp.hillClimbedGene,
        temp.lastIncrement,
        rotate(temp.lastResults, 0.0),
        lastMigrationFrom
      )

    p
  }

  def addGene(a: ActorSelection)(implicit ec: ExecutionContext, scheduler: Scheduler): Population = {
    println("adding gene")
    val bestIndividual = this.bestIndividual
    val clist =
      Range(0, individuals.length).map(i => (bestIndividual.chromosome.addRandomGene, "gene")).toList
    val newIndividuals = calc(clist, a)
    println("fitness calculated")

    this.copy(individuals = sort(newIndividuals),
              trend = "change",
              newBestAtGeneration = this.generation,
              totalFitness = newIndividuals.map(_.fitness).sum)

  }

  def doMigration(migration: List[Individual], a: ActorSelection, ec: ExecutionContext, otherPopulationIndex: Int)(
      implicit fitnessFunction: FitnessFunction,
      selection: SelectionFunction,
      mutation: MutationPointLike,
      dimension: ImageDimensions,
      crossover: CrossoverPointLike,
      temperature: Temperature): Population = {
    logger.debug("Migration from population " + otherPopulationIndex)

    var temp = this.migration(migration, a, ec)
    val oldBest = this.individuals.head
    var newBest = temp.individuals.head

    if (oldBest.fitness < newBest.fitness) {
      val lastI = newBest.fitness - oldBest.fitness
      Population(
        generation + 1,
        temp.individuals,
        temp.totalFitness,
        generation + 1,
        newBest.generatedBy,
        temp.hillClimbedGene,
        newBest.fitness - oldBest.fitness,
        rotate(lastResults, lastI),
        otherPopulationIndex
      )
    } else
      Population(
        generation + 1,
        temp.individuals,
        temp.totalFitness,
        this.newBestAtGeneration,
        oldBest.generatedBy,
        temp.hillClimbedGene,
        temp.lastIncrement,
        rotate(lastResults, 0.0),
        otherPopulationIndex
      )

  }

  def migration(list: List[Individual], a: ActorSelection, ec: ExecutionContext)(implicit fitnessFunction: FitnessFunction,
                                                                                 selection: SelectionFunction,
                                                                                 dimension: ImageDimensions,
                                                                                 mutation: MutationPointLike,
                                                                                 crossover: CrossoverPointLike,
                                                                                 temperature: Temperature): Population = {

    implicit val e = ec

    val splitted = individuals.splitAt(Population.EliteCount)
    var newIndividuals = splitted._1 // start with elite
    val choice = Random.nextInt(list.size)

    val offsprings = Range(0, Population.Size * 4).map { i =>
      val selected1 = list(choice)
      val selected2 = selection.select(this)
      selected1.chromosome.uniformCrossover(selected2.chromosome)
    }.toList

    val migrationList: List[(Chromosome, String)] = offsprings.map { individual =>
      (individual, "migration")
    }

    val futures: immutable.Seq[Future[Individual]] = migrationList.map { chromosome =>
      (a ? CalculateFitness(chromosome._1, generation, chromosome._2)).mapTo[CalculatedFitness].map { cf =>
        Individual(cf.chromosome, cf.fitness, cf.reason)
      }
    }

    val future: Future[immutable.Seq[Individual]] = Future.sequence(futures)

    val l: List[Individual] = Await.result(future, 60.seconds).toList

    newIndividuals = newIndividuals ++ l

    val totalFitness: Double = newIndividuals.map(_.fitness).sum

    Population(generation,
               sort(newIndividuals),
               totalFitness,
               newBestAtGeneration,
               bestReason,
               hillClimbedGene,
               lastIncrement,
               lastResults,
               lastMigrationFrom)
  }

  def crossOver(a: ActorSelection, ec: ExecutionContext)(implicit fitnessFunction: FitnessFunction,
                                                         selection: SelectionFunction,
                                                         dimension: ImageDimensions,
                                                         mutation: MutationPointLike,
                                                         crossover: CrossoverPointLike,
                                                         temperature: Temperature,
                                                         scheduler: Scheduler): Population = {

    implicit val e = ec

    val splitted = individuals.splitAt(Population.EliteCount)
    var newIndividuals = splitted._1 // start with elite
    val offsprings = Range(0, Population.Size).map { i =>
      val selected1: Individual = selection.select(this)
      var selected2 = selection.select(this)
      while (selected1 == selected2) selected2 = selection.select(this)
      selected1.chromosome.uniformCrossover(selected2.chromosome)
    }.toList

    val chanceOfMutation = 15
    val mutationSize = 1
    val times = 1
    val mutationList: List[(Chromosome, String)] = offsprings.map { individual =>
      val r = Random.nextInt(100)

      if (r < chanceOfMutation)
        (individual.mutate(times)(mutation, mutationSize), "mutation")
      else
        (individual, "crossover")
    }

    val futures: immutable.Seq[Future[Individual]] = mutationList.map { chromosome =>
      (a ? CalculateFitness(chromosome._1, generation, chromosome._2)).mapTo[CalculatedFitness].map { cf =>
        Individual(cf.chromosome, cf.fitness, cf.reason)
      }
    }

    val future: Future[immutable.Seq[Individual]] = Future.sequence(futures)

    val l = calc(mutationList, a)

    newIndividuals = newIndividuals ++ l

    val totalFitness: Double = newIndividuals.map(_.fitness).sum

    Population(generation,
               sort(newIndividuals),
               totalFitness,
               newBestAtGeneration,
               bestReason,
               hillClimbedGene,
               lastIncrement,
               lastResults,
               lastMigrationFrom)
  }

  def calc(cList: List[(Chromosome, String)], a: ActorSelection)(implicit ec: ExecutionContext, scheduler: Scheduler): List[Individual] = {
    val futures: immutable.Seq[Future[Individual]] = cList.map { chromosome =>
      (a ? CalculateFitness(chromosome._1, generation, chromosome._2)).mapTo[CalculatedFitness].map { cf =>
        Individual(cf.chromosome, cf.fitness, cf.reason)
      }
    }

    val future: Future[immutable.Seq[Individual]] = Future.sequence(futures)

    val f = retry(future, 120.seconds, 5)

    Await.result(f, 120.seconds).toList
  }

  def neighbour(chromosome: Chromosome, gene: Int): List[Chromosome] = {
    it.codingjam.lagioconda.conversions.neigh(chromosome.genes(gene)).map { g =>
      Chromosome(chromosome.genes.slice(0, gene) ++ List(g) ++ chromosome.genes.slice(gene + 1, chromosome.genes.length))
    }
  }

  def hillClimb(a: ActorSelection, ec: ExecutionContext, temperature: Temperature, gene: Int)(
      implicit mutation: MutationPointLike): Population = {

    implicit val e = ec

    println("Hill climb with gene " + gene + " at generation " + this.generation + " fit " + bestIndividual.fitness)

    def hc(chosen: Individual): Individual = {
      val l: List[Chromosome] = neighbour(chosen.chromosome, gene)

      val f = fitness(a, l, generation, "hillClimb")
      sort(f).head
    }

    var i = 1
    var startingPoint = bestIndividual
    var hillClimber = hc(startingPoint)
    var bestSoFar = if (startingPoint.fitness > hillClimber.fitness) startingPoint else hillClimber

    if (bestIndividual.fitness < bestSoFar.fitness) {
      val selected = (List(bestSoFar) ++ this.individuals).dropRight(1)
      val total = selected.map(_.fitness).sum
      println("Successfull Hill climb with gene " + gene)
      val lastI = bestSoFar.fitness - bestIndividual.fitness

      Population(generation,
                 selected,
                 total,
                 newBestAtGeneration,
                 bestReason = "hillClimb",
                 gene,
                 lastI,
                 rotate(lastResults, lastI),
                 lastMigrationFrom)
    } else {
      println("*failed* Hill climb with gene " + gene)
      this.copy(hillClimbedGene = ((hillClimbedGene + 1) % bestIndividual.chromosome.genes.length), lastResults = rotate(lastResults, 0.0))
    }

  }

  private def fitness(a: ActorSelection, list: List[Chromosome], generation: Int, reason: String)(implicit ec: ExecutionContext) = {
    val futures: immutable.Seq[Future[Individual]] = list.map { chromosome =>
      (a ? CalculateFitness(chromosome, generation, reason)).mapTo[CalculatedFitness].map { cf =>
        Individual(cf.chromosome, cf.fitness, reason)
      }
    }
    val future: Future[immutable.Seq[Individual]] = Future.sequence(futures)
    Await.result(future, 120.seconds).toList
  }

  private def splitEitherList[A, B](el: List[Either[A, B]]) = {
    val (lefts, rights) = el.partition(_.isLeft)
    (lefts.map(_.left.get), rights.map(_.right.get))
  }

  private def sort(list: List[Individual]) = list.sorted(Ordering[Individual]).reverse

  def addIfNotClone(list: List[Individual], newIndividual: Individual) = {
    val l: Seq[Individual] = list.filter(i => i.fitness == newIndividual.fitness)
    val m: Seq[Set[Gene]] = l.map(i => i.chromosome.genes.toSet)
    val n = m.find(set => set.equals(newIndividual.chromosome.genes.toSet))
    if (n.isDefined)
      list
    else list :+ newIndividual
  }

  def bestIndividual = individuals.head

  def randomIndividual: Individual =
    individuals(Random.nextInt(individuals.size))

  def randomNotElite: Individual = individuals(Population.EliteCount + Random.nextInt(Population.Size - Population.EliteCount))

  def randomElite: Individual = individuals(Random.nextInt(Population.EliteCount))

  def randomPositionAndIndividual: (Int, Individual) = {
    val pos = Random.nextInt(individuals.size)
    (pos, individuals(pos))
  }

  def randomIndividualInRange(position: Int) = {

    def normalizedPosition(i: Int) = {
      if (i < 0) 0
      else if (i > individuals.size - 1) individuals.size - 1
      else i
    }

    val range = 12
    val pos = position - (range / 2) + Random.nextInt(range)
    individuals(normalizedPosition(pos))
  }

  def randomIndividualByWeight: Individual = {
    val total = (individuals.size * (individuals.size + 1)) / 2
    var r = Random.nextInt(total)
    var x = individuals.size
    while (r > 0) {
      r = r - x
      x = x - 1
    }
    val position = individuals.size - x - 1
    individuals(if (position >= 0) position else 0)
  }

  def meanFitness: Double = totalFitness / individuals.size

}

object Population {

  val Size = 40
  val EliteCount = 4
  val MaxRotate = 500

  def randomGeneration()(implicit fitnessFunction: FitnessFunction, dimension: ImageDimensions, configuration: Configuration): Population = {

    var list: List[Individual] = List()

    Range(0, Size).foreach { i =>
      val c: Chromosome = RandomChromosome.generate(Gene.Size, 1)
      val fitness = fitnessFunction.fitness(c)
      val individual = Individual(c, fitness, "random")
      list = list :+ individual
    }

    Population(0, list.sorted(Ordering[Individual].reverse), list.map(_.fitness).sum, 0, "random", 0, 0.0, List(), 0)
  }

}
